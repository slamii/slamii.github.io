---
layout: post
title: Monads
---

### Motivational introduction
Functional languages are founded on the idea of function 
composition; having $f: A \longrightarrow B$ and 
$g: B \longrightarrow C$ we can create a composition
$g \circ f: A \longrightarrow C$.
Suppose now those functions have some additional, common
flavour e.g. they may not return a result (like $f(x)=\frac{1}{x}$ for $x=0$) or return 0 or more results (like for a function computing possible chess positions from a given position).

In a strongly typed language we'd represent this additional behaviour by
a different type of the return value. Let's stick to the example of 
possibly not returning a value. We'd introduce a type constructor `Maybe`, $M$ for short, and our functions would have signatures $f:A \longrightarrow MB$ and $g:B \longrightarrow MC$.

We still do want to compose them; the additional behaviour should not hinder us, they both have it. But now the types are incompatible. We want 
to apply $g$ after $f$ but $g$ accepts type $B$, not $MB$. We are stuck. Monads are a device to break this impasse, let's keep this in mind for the rest of the section.

Taking a step back, another thing besides composition of functions that we would can employ is the identity function $id: A \longrightarrow A$, a trivial computation for any type $A$. Now, it turns out that there is a mathematical structure built on top of these two properties called a category.

It belongs to Category Theory, a mathematical area that tries to describe things in the most general way possible. Thus the definition of a category is very simple: 
> A **category** $\mathcal{C}$ is a collection of: 
> 1. **objects** $A, B, \ldots$
> 2. **morphisms** or **arrows** (which you could think of as maps)
>
> where the morphisms have the objects of $\mathcal{C}$ as domain and codomain, e.g. $f:A \longrightarrow B$. The morphisms of corresponding domains and codomains have to be composable in the way you'd expect and each object has its **identity morphism** $id_A:A \longrightarrow A$ that acts trivially in the composition. 

For more details refer to [Johnstone notes].

Now, further into Category Theory, there is a notion of a **monad**. Regardless of what is its mathematical definition (refer to 5.1 in [Johnstone notes]), a monad $M$ on a category $\mathcal{C}$ gives us another category, the **Kleisli category** $\mathcal{C}_\mathbb{T}$, whose morphisms are morphisms in $\mathcal{C}$ of the form $f:A\longrightarrow MB$. The fact that it's a category means we can compose those morphisms. This is what we wanted all along and this is what monads give us.

### What is a monad?

Much in the spirit of the above reasoning, the definition of a monad in
computer science as given by [nLab] is as follows:
> A **monad** is a map $M$:
> 1. sending every type $X$ of a given programming language to a new type
$MX$.
> 2. equipped with a rule for composing two functions of the form
$f: X \longrightarrow MY$ and 
$g: Y \longrightarrow MZ$ to $gf: X\longrightarrow MZ$.
The functions are called **Kleisli functions** and the composition the **Kleisli composition**.
> 3. together with a map $\mathrm{pure}_X: X\longrightarrow MX$
for every type $X$ that acts trivially in the composition.
The Kleisli composition is required to be [associative](https://en.wikipedia.org/wiki/Associative_property).

A definition offered by [Haskell All About Monads] is more down to earth:
> A **monad** is:
> 1. a type constructor $m$
> 2. a function building values of type $m$, $a \longrightarrow ma$ for any type $a$ called **return**
> 3. a combinator function called **bind** of the form $(ma, a \longrightarrow mb)\longrightarrow mb$ for any type $a, b$. Usually written $ma >== a \longrightarrow mb$.

The definition above has to also satisfy the laws equivalent to the third point in the nLab's definition. Unless otherwise stated, we will be referring to the first definition.

A natural question to ask would be about the meaning of the $\mathrm{pure}$ function and its counterpart from the second definition -- bind. If all we want is a composition and this is guaranteed by the second point in the definition, why bother with the third?

What the third one ensures is that the computations of the form $A\longrightarrow MB$ have the structure of a category, the aforementioned Kleisli category. What this means in practice is that we're excluding from the definition some pathological cases. The requirement of forming a category is a very basic one and if we loosen it the things we will thus gain would be irregular enough for them not to be of practical use anyway.

For now we will leave the following as an open question: what additional structures could we get by dropping 3? One should be interested in finding both the most pathological examples to see what we are saving ourselves from, as well as the least obscene ones to see on the other hand what we could potentially be missing.


### Examples of monads in programming languages

### Background
The term **monad**, from Greek *monas*, "unit", was first used by Giordano Bruno.
He claimed the world is *homogeneous*, *one*. Nevertheless, it consists of a multitude
of self-contained units. Like a point, *mathematical minimum*, is a basic component of space,
and an atom, *physical minimum*, of that of matter - monad is a *metaphysical minimum*. Their
shapes and formes are unique (which followed naturally from God being the ultimate perfect
creator).


